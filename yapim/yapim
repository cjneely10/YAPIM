#!/usr/bin/env python
import os
import pickle
from importlib import import_module
from inspect import isclass
from pathlib import Path
from typing import Optional, List, Type

from plumbum import cli

from yapim.utils.config_manager import ConfigManager
from yapim.utils.config_manager_generator import ConfigManagerGenerator
from yapim.utils.executor import Executor
from yapim.utils.extension_loader import ExtensionLoader
from yapim.utils.input_loader import InputLoader


class YAPIM(cli.Application):
    """
    Create and run Yet Another PIpeline (Manager)
    """
    VERSION = "0.1.0"

    def main(self, *args):
        if args:
            print("Unknown command {0!r}".format(args[0]))
            exit(1)
        if not self.nested_command:
            self.help()
            exit(1)


pipeline_file = ".pipeline.pkl"


@YAPIM.subcommand("config")
class YAPIMConfigCreator(cli.Application):
    """
    Create configuration file and pipeline path data
    """
    tasks_directory: Path
    loader: Type[InputLoader] = ExtensionLoader
    dependencies_directories: Optional[List[Path]] = None
    config_path: Path
    overwrite: bool = True

    @cli.switch(["-l", "--loader"], str)
    def set_loader(self, loader_name):
        """Path to custom loader class extending InputLoader"""
        if not os.path.exists(loader_name) or not os.path.isfile(loader_name):
            print("Unable to find loader")
            exit(1)
        self.loader = _get_loader(loader_name)

    @cli.switch(["-t", "--tasks"], str, mandatory=True)
    def set_tasks_dir(self, tasks_dir):
        """Path to directory of pipeline Task/AggregateTasks"""
        if not os.path.exists(tasks_dir) or not os.path.isdir(tasks_dir):
            print("Unable to find tasks directory")
            exit(1)
        self.tasks_directory = Path(tasks_dir).resolve()

    @cli.switch(["-d", "--dependencies"], str, list=True)
    def set_dependencies_directory(self, dependencies):
        """Path to directory of Task/AggregateTask dependencies"""
        for i in range(len(dependencies)):
            if not os.path.exists(dependencies[i]) or not os.path.isdir(dependencies[i]):
                print("Unable to find dependencies directory")
                exit(1)
            dependencies[i] = Path(dependencies[i]).resolve()
        self.dependencies_directories = dependencies

    @cli.switch(["-c", "--config"], str, mandatory=True)
    def set_config_path(self, config):
        """Path to configuration file"""
        self.config_path = Path(config).resolve()
        if self.config_path.exists():
            self.overwrite = input("Overwrite existing configuration file? [Y/n]: ").upper() == "Y"

    def main(self):
        if self.overwrite is True:
            ConfigManagerGenerator(self.tasks_directory, self.dependencies_directories).write(self.config_path)
        pipeline_data = {
            "loader": self.loader,
            "tasks": self.tasks_directory,
            "dependencies": self.dependencies_directories
        }
        out_file = self.tasks_directory.joinpath(pipeline_file)
        if not out_file.exists() or input("Overwrite existing pipeline file? [Y/n]: ").upper() == "Y":
            with open(out_file, "wb") as json_file:
                pickle.dump(pipeline_data, json_file)


def _get_loader(loader_name: str) -> Type[InputLoader]:
    current_dir = os.getcwd()
    os.chdir(os.path.dirname(loader_name))
    module = import_module(os.path.basename(os.path.splitext(loader_name)[0]))
    for attribute_name in dir(module):
        attribute = getattr(module, attribute_name)
        if isclass(attribute) and issubclass(attribute, InputLoader) and loader_name in attribute.__name__:
            os.chdir(current_dir)
            return attribute
    os.chdir(current_dir)
    print("Unable to import loader module")
    exit(1)


def _validate_pipeline_pkl(pipeline_path: Path) -> dict:
    pipeline_data: dict
    with open(pipeline_path, "rb") as provided_pipeline_file:
        pipeline_data = pickle.load(provided_pipeline_file)
    for key in ("tasks", "dependencies"):
        if key not in pipeline_data.keys() or \
                (isinstance(pipeline_data[key], Path) and not pipeline_data[key].exists()):
            print(f"Unable to load {key} {pipeline_data[key]}")
            print(f"Re-run yaml config to update pipeline")
            exit(1)
    if "loader" not in pipeline_data.keys() or not issubclass(pipeline_data["loader"], InputLoader):
        print(f"Unable to validate loader")
        exit(1)
    return pipeline_data


@YAPIM.subcommand("run")
class YAPIMRunner(cli.Application):
    """
    Run a pipeline
    """
    input_directory: Optional[Path] = None
    config_path: Path
    output_directory: Optional[Path] = Path(os.getcwd()).joinpath("out")
    pipeline_pkl_path: Path
    display_status: bool = True

    @cli.switch(["-i", "--input"], str)
    def set_input(self, input_directory):
        """Path to input directory"""
        if not os.path.exists(input_directory) or not os.path.isdir(input_directory):
            print("Unable to locate input directory")
            exit(1)
        self.input_directory = input_directory

    @cli.switch(["-c", "--config"], str, mandatory=True)
    def set_config_path(self, config):
        """Path to configuration file"""
        if not os.path.exists(config) or not os.path.isfile(config):
            print("Unable to load config file")
            exit(1)
        self.config_path = Path(config).resolve()

    @cli.switch(["-p", "--pipeline"], str, mandatory=True)
    def set_pipeline_path(self, pipeline):
        """Path to directory containing pipeline.pkl file"""
        self.pipeline_pkl_path = Path(pipeline).resolve().joinpath(pipeline_file)
        if not self.pipeline_pkl_path.exists():
            print("Unable to find pipeline .pkl file")
            exit(1)

    @cli.switch(["-o", "--output"], str)
    def set_output_dir(self, output):
        """Path to output directory, default is <current-dir>/out"""
        self.output_directory = Path(output).resolve()

    @cli.switch(["-s", "--silence"])
    def set_verbosity(self):
        """Do not display log statements to stdout"""
        self.display_status = False

    def main(self, *args):
        pipeline_data = _validate_pipeline_pkl(self.pipeline_pkl_path)
        if pipeline_data["loader"].__name__ == ExtensionLoader.__name__:
            if self.input_directory is None:
                print("Must set input directory for default ExtensionLoader")
                exit(1)
            Executor(
                pipeline_data["loader"](
                    self.input_directory, self.output_directory.joinpath(ConfigManager.STORAGE_DIR)
                ),
                self.config_path,
                self.output_directory,
                pipeline_data["tasks"],
                pipeline_data["dependencies"],
                self.display_status
            ).run()
        else:
            Executor(
                pipeline_data["loader"](*args),
                self.config_path,
                self.output_directory,
                pipeline_data["tasks"],
                pipeline_data["dependencies"],
                self.display_status
            ).run()


if __name__ == "__main__":
    YAPIM.run()
